\section{Analysing Conflicts}\label{conflict}
In software development, especially in agile methods, conflict analysis is an important task to ensure the coherence and functionality of the system to be developed. A conflict is defined as a inconsistency that arises when two or more requirements, often encapsulated as USs, contradict each other. This section will introduce and define conflicts analysis, focusing on the concept of \textit{content inconsistency} between USs.

The main objective of this analysis is to rationalise the software development workflow by semantically identifying conflicts between the USs within the backlog of a project.

A conflict of requirements arises when two or more USs show contradictions or inconsistencies. This can manifest itself in various forms, e.g. in the manipulation of the same resource by several USs at the same time, in overlapping functions or in conflicting conditions.

\begin{example}
	Considering following USs:\\\\
	user\_story\_327: "\#G03\# As a Staff member, I want to apply a hold, so that I can prevent progression through the workflow or other actions in the system until the issue is resolved."\\\\
	user\_story\_328: "\#G03\# As a Staff member, I want to remove a hold, so that I can allow progression through the workflow or other actions in the system now that the issue has been resolved."\\\\
	In this example, user\_story\_328 deletes a resource that is used by user\_story\_327. This means that user\_story\_327 cannot be applied at all if user\_story\_328 is executed first, which leads to a conflict between these USs.
\end{example}

In Section \ref{conflict_related_work} we discuss about related work. In Section \ref{conflict_requirement} we present the requirements and functional needs that serve as input for the design phase to fulfil them. In Section \ref{conflict_desing} we explain the design decisions of the workflow shown in Figure \ref{fig:conflict_operational_flow} and explain how the architecture is structured. In Section \ref{conflict_implementation} we go into the implementation steps. In Section \ref{conflict_evaluation} we evaluate our research with two research questions (RQs) and in Section \ref{conflict_conclustion} we conclude our work.
\subsection{Related Work}\label{conflict_related_work}
Kim et al. introduce a method for identifying and managing conflicts in software requirements. This method involves dividing requirements written in natural language and is supported by a specialized tool \cite{kim2007managing}.

In addition, Kim et al. assert that there is a lack of methods to systematically identify and manage conflicts between requirements written in natural language within the product line context. To address this issue, they introduce a linguistic technique that detects conflicts in requirements by utilizing \textit{goals} and \textit{scenarios}. These goals and scenarios are expressed in natural language, specifically English.

Requirements conflicts are described as interactions and dependencies between requirements that can cause the system to function in an unintended or undesired way. An example from the mobile phone domain is given: If both the "automatic response function" and the "deny reception function" are activated at the same time, a conflict arises. If a call comes in from a number that should not be answered, "automatic response function" would conflict with the "deny reception function".

They used the goals and scenarios using an authoring structure that follows the format \texttt{action (verb) + object (object) + resource (resource)} as described by Kim et al. \cite{kim2004method,kim2004multi} and Rolland et al. \cite{rolland1998guiding}. Before they described the specific requirements, they created a function dictionary in which various system functions are listed. However, they did not mention how they created the dictionary.

If action and object cause the conflict, this can lead to an activity conflict. On the other hand, a resource conflict can occur when different components try to use the same resources simultaneously, resulting in a conflict.

Kim et al. used two methods for detecting conflicts: \textit{syntactic} and \textit{semantic}. The syntactic method identifies potential conflicts among requirements based on predefined conditions. The semantic method then focuses on detecting actual conflicts by analysing the candidate conflicts.

Their approach is not well suited to agile development projects, as these projects usually use the US notation as a standard structure. In addition, they have not considered how elements such as objects, resources and verbs relate to each other, which makes it more difficult to recognise conflicts. They also overlook the importance of containment objects and resources when analysing conflicts.

Lambers et al. present a static CDA technique for graph transformations that can identify conflicts and dependencies at multiple levels of granularity in software development. This new technique significantly improves the speed of fine-grained CDA computations and extends them with coarse-grained results, providing usability benefits in various use-cases. It is particularly useful for analysing interactions in complex and dynamic object structures, such as feature interactions in software product line development \cite{lambers2018multi}.

Lambers et al. discuss the use of CDA in different areas of software development and the requirements for the granularity of these applications. They categorise the use-cases into:
\begin{itemize}
	\item Software System Design and Analysis: Here, behavioural models such as activity models and live sequence diagrams are checked using rule-based specifications. 
	
	\item Model-Driven Engineering: This involves model transformations in which the CDA helps to recognise and explain conflicts and dependencies between transformation specifications.
	
	\item Optimization of Rule-Based Computations: CDA is used to identify conflicting or interdependent rule pairs in order to optimise calculations and avoid or postpone backtracking.
\end{itemize}
However, the application of GT in USs to analyse conflicts is still unexplored.
\subsection{Requirements}\label{conflict_requirement}
In order to accomplish the analysis of conflicts in USs we try to address following functional requirements:
\begin{itemize}
	
	\item As a user, I want to perform semantic analysis on user stories within a specified project backlog, so that I can identify and address conflicts effectively.
	
	\item As a user, I want a report on the US-pairs that are conflicting in the main parts, so that I can change them if needed.
	
	\item As a user, I want to apply a filter to the conflict report to  show US-pairs that have the same resource (as entity) with different verbs (as action), so that the verbs are semantically contradictory (e.g. one US deletes a resource that another US is using/deleting or one US creates a resource that another US prohibits).
	
	\item As a user, I want to analyse conflicts between US-pairs with different resources, where one resource acts as a child of another resource, so that this type of relationship can also be analysed.
	
	%\item As a user, I want to mark found redundancy clauses as Triggers with a hash symbol (\#) and show those that have a redundancy in \enquote{Persona} (as a noun) and \enquote{Action} (as a verb) entries, so that I can better see if the persona in is also recognised as a redundancy.
	
	\item As a user, I want to mark the container relation with a hash symbol (\#) and display found resources as a conflict element (as a noun) so that I can better recognise whether the contained entity is also recognised as a potential conflict.
	
	\item As a user, I would like to have a conflict report that shows founded US-texts pairwise and adds a hash symbol (\#) at the beginning and end of conflicting verbs and the noun (as a resource) as a marker, so that I can better recognise the verbs and the noun that conflict in US-pairs.
	
	\item As a user, I want to see how many conflicted US-pairs have been founded in the main parts of the USs within a backlog, so that I can summarise conflict US-pairs founded on this basis for further statistical purposes.
	
	\item As a user, I want a table at the top of the conflict report that lists the US-pairs in conflict, so that I can quickly see all the US-pairs that have been founded.
	
\end{itemize}
To judge the operation of the system, we define following non-functional requirements:
\begin{itemize}
	\item Testability: The system should support automated test procedures to ensure that semantic analysis and conflict detection work correctly. It should include comprehensive test cases covering different scenarios, including edge cases, to verify the accuracy and reliability of conflicts analysis.
	
	\item Documentation: The system should include detailed documentation covering all aspects of functionality and setup.
	
	\item Performance: The system should perform the conflicts analysis within a reasonable time frame, even with large project backlogs. It should be optimised so that it can process large volumes of data without any significant loss of performance.
	
	\item Scalability: The system should be scalable to handle an increasing count of USs and larger project backlogs.
		
\end{itemize}

\subsection{Design}\label{conflict_desing}
This section describes the operational flow and architectural considerations that underpin the framework.

In our project, we initially considered using the Henshin API and CDA to implement conflicts analysis between USs. The target was to show that GT can effectively analyse conflicts between USs. However, after further evaluation, we realised that using Henshin and CDA was not the most efficient approach for our needs.

While graph transformations are useful and suitable for our task, they introduce additional steps into the conflicts analysis process that can be time-consuming and complex. Our target was to streamline the process and get results faster, which required a simpler approach.

To overcome these challenges, we have developed our own tool inspired by Henshin and CDA tools. Our tool focusses on the core task of conflicts analysis but is designed to be faster as it does not require any further steps (e.g. creating rules, applying CDA to rules and interpreting the delivered reports). In this way, we can achieve similar results in a more straightforward and faster way.

\subsubsection*{Design Overview}
To address the requirements specified in Section \ref{conflict_requirement}, our system used the backlogs labelled with Doccano tool\footnote{\href{https://github.com/ace-design/nlp-stories}{https://github.com/ace-design/nlp-stories}} generated by Mosser et al. as the primary input \cite{arulmohan2023extracting}.

To carry out the conflicts analysis, a one-time preparatory phase is required, in which a database is created using the verb classification of VerbNet (VN), which contains categorised verbs in the four categories "create", "delete", "preserve", "forbid" (from now on) called \textit{action-annotations}. Once this is done, the conflicts analysis can be applied to the USs using this database and the specific criteria.

After the conflicts analysis has been applied, a comprehensive report is produced containing information on the conflicting US-pairs in text and table form. Finally, a conflicts assessment phase is initiated for further statistical purposes.

Figure \ref{fig:conflict_operational_flow} illustrates how each step in this workflow is interconnected, with the output of one step feeding directly into the next. This diagram effectively demonstrates the toolchain and process workflow, highlighting how each step transforms artefacts and contributes to the overall objective of analysing conflicts.
\begin{figure}[h]
	\centering 
	\includegraphics[scale=0.65]{conflict_operational_flow}
	\caption{Step-by-step visualisation of the toolchain and its inputs and outputs}\label{fig:conflict_operational_flow}
\end{figure}
\paragraph{One-Time-Phase: Creating database for annotated verbs}To create a database of verbs and their associated action-annotations, we first need to collect all verb classes and their common semantic labels, called verb types, from the VN databases as follows:
\begin{enumerate}
	\item Each XML file corresponding to each VN top-level class from the Git repository\footnote{\href{https://github.com/cu-clear/verbnet}{https://github.com/cu-clear/verbnet}}.
	
	\item Collecting verb types from VN documentation\footnote{\href{https://verbs.colorado.edu/verb-index/VerbNet_Guidelines.pdf}{https://verbs.colorado.edu/verb-index/VerbNet\_Guidelines.pdf}}: Since the verb types of verb classes is not included in the XML files. We then collect all verb types and their verb classes from the \textit{VerbNet guideline} PDF file in an CSV file.
	
	\item Adding verb types to XML files: We implement a Python script \texttt{addverbtype.py}\footnote{\href{https://github.com/amirrabieyannejad/conflict_analysis_between_USs/tree/main/Code/VN_Verb_Categorisation/01_add_verbType}{https://github.com/conflict\_analysis\_between\_USs/Code/01\_add\_verbType}} to add verb types to XML files based on the provided CSV file.
	
	\item Extracting verbs and verb types from XML files: Now we extract all verbs that belong to a verb class and their verb type into a CSV file using an implemented Python script \texttt{member\_extractor.py}\footnote{\href{https://github.com/amirrabieyannejad/conflict_analysis_between_USs/tree/main/Code/VN_Verb_Categorisation/02_member_extractor}{https://github.com/conflict\_analysis\_between\_USs/Code/02\_member\_extractor}}.
\end{enumerate}
Finally, based on verb types, each verb annotated into four action-annotations. 

To validate the action-annotations, a personal judgement is made for each verb by three evaluators, so that each person reviews the action-annotations for each verb and comments their own action-annotations. We then collect all the personal judgements and combine the action-annotations for each verb. The action-annotation reference database is available in Git repository\footnote{\href{https://github.com/amirrabieyannejad/conflict_analysis_between_USs/blob/main/actions_annotations.csv}{https://github.com/conflict\_analysis\_between\_USs/main/actions\_annotations.csv}}.
%\paragraph{Translating the JSON-Format of the Primary Input}\label{conflict_workflow_preparing_json_format}
%Since the annotated USs in the original JSON files did not split entries such as "Entity", "Action", "Text", "Targets" and "Contains", it is not clear which element belongs to which part of the USs (main or benefit part), which leads to possible ambiguities.

%Accordingly, we use a class called \textit{USPartExtractor} that separates entries based on their occurrence in both the main and benefit parts of the USs. It also specifies an identifier to assign a unique identifier to each US, which is stored in a JSON object called \textit{"US\_Nr"}. 

%These additions improve the system's ability to distinguish and process individual USs within the analytical pipeline.
\paragraph{Conflict Analysis and Extraction of Text Reports} The goal of creating a text report is to identify conflicts between USs and emphasize key information. This process includes:
\begin{itemize}
\item Identifying potential conflict pairs.

\item Determining the reasons for these conflicts.

\item Identifying the resources (nouns) affected by actions (verbs) that cause the conflicts.

\item Display of main parts of the texts of USs, with the affected elements marked with "\#".

\item Tabulating the potentially conflicting US-pairs for clarity.
\end{itemize}
\paragraph{Evaluating the reports} After we have created the reports, we can now assess the correctness of the US-pairs reported as potential conflicts, i.e. whether the reported US-pairs actually cause conflicts.
\subsubsection*{Software Architecture}\label{conflict_architectur}
In this section, we present the basic structures of our workflow and the discipline of creating such structures. Each structure comprises software elements, relations among them, and properties of both.
\begin{itemize}
	\item Annotated USs with Doccano Tool\footnote{\href{https://github.com/doccano/doccano}{https://github.com/doccano/doccano}}: Mosser et al. used publicly available requirements from Dalpiaz et al. \cite{Dalpiaz2018} consisting of 22 product backlogs and 1,679 USs. The dataset is a raw archive of 22 text files, each containing one US per line. 
	
	As there were no public expert-based annotations, Mosser et al. annotated the datasets using the Doccano tool. Labels included persona, action, entity, benefit part and relations such as triggers, targets, and contains based on their domain meta-model.
	
	As artefact we receive a graph-based model with JSON format, which represents the refined and annotated datasets for the recognition of entities, actions, personas and benefits of USs \cite{mosser2022modelling}.
	
	\item Eclipse as IDE\footnote{\href{https://eclipseide.org/}{https://eclipseide.org/}}: Eclipse is an integrated development environment (IDE) used in computer programming. It contains a base work workspace and an extensible plug-in system for customizing the environment.
	
	\item VerbNet (VN) as Verb Lexicon Resource\footnote{\href{https://verbs.colorado.edu/verbnet/}{https://verbs.colorado.edu/verbnet/}}: VN is the largest on-line network of English verbs that links their syntactic and semantic patterns. It is a hierarchical, domain-independent, broad-coverage verb lexicon with mappings to other lexical resource, such as WordNet\footnote{\href{https://wordnet.princeton.edu/}{https://wordnet.princeton.edu/}}, PropBank \footnote{\href{https://propbank.github.io/}{https://propbank.github.io/}}, and FrameNet \footnote{\href{http://framenet.icsi.berkeley.edu/}{http://framenet.icsi.berkeley.edu/}}. 
	
	VN is organized into verb classes extending Levin (1993) classes through refinement and addition of subclasses to achieve syntactic and semantic coherence among members of a class. Each verb class in VN is completely described by thematic roles, selectional preferences of the arguments, and frames consisting of a syntactic description and a semantic representation with subevent structure patterned on the dynamic event model of Pustejovsky and Moszkowicz and Pustejovsky \cite{kipper2006extending}.
	
	\item USPartExtractor Class: This class is part of the \textit{org.backlogconflict .code.preparation} package and is a key component of the software architecture designed for transforming primary input datasets in the specific JSON format. It separates elements based on their occurrence in both the main and benefit parts of the USs.
	
	This process simplifies subsequent tasks for editing, analysing and conflict resolution by providing a clear structure for the USs and their components. The separation of main and benefit parts improves the manageability and traceability of USs within the system.
	
	\item Action-Annotation Reference Database: This database is essential for identifying conflicts between USs, especially conflicts arising from actions over common entities (as resources). To achieve this, we categorise verbs into four action-annotation.
	
	The main purpose of the action-annotation reference database is to facilitate conflict analysis by translating actions (in the form of verbs) found in USs into their corresponding action-annotations.
	%\begin{enumerate}
	%	\item Collection of Actions: We collect all actions (represented as verbs) from existing datasets and compile them into a CSV file. This file serves as comprehensive reference database.
		
	%	\item Contextual Translation: Each verb in the CSV file is translated into the corresponding action-annotations related to its VerbNet class. 
		
	%	\item Personal Judgement: To validate the action-annotations, three evaluators individually assess each verb. Each evaluator reviews the annotations and provides their own comments. We then gather these individual assessments and combine them to finalize the action-annotation reference database for each verb.
%	\end{enumerate}
	
	\item VerbFinder Class: The VerbFinder class is an essential component within the \textit{org.backlogconflict.code.preparation} package, designed to interface with the action-annotation database and facilitate the process of mapping verbs to their corresponding action-annotations. 
	
	\item ActionsAnnotationsCreator Class : This class is a component within the \textit{org. backlogconflict.code.preparation} package. Its primary function is to improve the extraction of parts of USs process by incorporating action-annotations into the JSON datasets. 
	
	The class adds entries that consist of a set of triples: "action", "entity", and "action-annotations". These action-annotations are sourced from the reference database. The matching process is done using the VerbFinder class. 
	
	\item ReportMaker Class: This class developed within the \textit{org.backlogconflict.code.report} package, its primary function is to identify conflicting US-pairs based on specific criteria and generate comprehensive reports on these conflicts. It performs the following key tasks:%This class provides detailed information on the nature of the conflicts, making it an invaluable tool for maintaining system coherence and resolving inconsistencies. 
	\begin{enumerate}
		\item Identification of conflicting US-pairs: The class analysis USs to identify conflicting US-pairs based on predefined criteria.
		
		\item Detailed Conflict Reports: Once conflicts are identified, the class generates detailed reports. These reports contain essential information such as the affected entity (as resource), potential conflicted actions, conflict reason, and the texts of main parts of the USs with marked elements with hash symbol (\#).
		
		\item Tabular Summary: In addition to detailed conflict descriptions, the class also produces a tabular summary of all identified conflicting US-pairs in a backlog, providing a quick overview of the conflict US-pairs.
	\end{enumerate}

	
\end{itemize}
Figure \ref{fig:conflict_technical_implementation} shows the architectural composition, highlighting the integral components and their user interface and artefacts.
\begin{figure}[h]
	\centering 
	\includegraphics[scale=0.6]{conflict_technical_implementation}
	\caption{Design phases}\label{fig:conflict_technical_implementation}
\end{figure}

Regarding conflict, some definitions are clarified:
\begin{definition}[\textbf{Customized User Story}]
	In order to apply conflicts analysis to the backlog, a customized US is defined, which consists solely of the main part that collectively describes what the user wants and the consequences of this need for the resources.
\begin{itemize}
	\item The \textit{main part} is essential as it clearly and concisely summarizes the persona, the intended functionality, and the resources required to perform the action. This part usually follows the format: \textit{"As a [persona/s], I want [actions over entities]."}
	
	In this customized US, the intended functionality, which describe the action that the persona wants to perform or the function they need, will be translated into four action-annotations: "create," "delete", "preserve", or "forbid". These action-annotations serve to standardize the actions for conflicts analysis:
	
	\begin{itemize}
		\item \textbf{Create:} This action-annotation describes the introduction or addition of a new entity within the system. For example, the action "apply" in US \textit{"As a staff member, I want to apply for a hold."} is annotated with "create".
		
		\item \textbf{Delete:} This action-annotation indicates the removal or elimination of an entity from the system. For example, the action "remove" in US \textit{"As a staff member, I want to remove a hold."} is annotated with "delete".
		
		\item \textbf{Preserve:} This action-annotation involves safeguarding, or using an existing entity without alterations. For example, the action "browse" in US \textit{"As a researcher, I want to browse through files in a collection."} is annotated with "preserve".
		
		\item \textbf{Forbid:} This action-annotation specifies prohibiting certain actions on an entity. For example, the action "restrict access" in US \textit{"As a collection curator, I want to restrict access to my collection or items to duke IP addresses."} is annotated with "forbid".
	\end{itemize}
	
	Specifying the resources required to perform the action helps with planning and resource allocation, ensuring that the development team is aware of the tools, technologies, and time required. This includes identifying all entities involved in the actions described and their relations.
	
	In other words, with respect to the action, we translate it into the aforementioned action-annotations for conflicts analysis. This translation standardizes the actions, making it easier to identify and resolve conflicts between USs.
	
	It is worth noting that in this form of US, the benefit part is not considered as part of the structure of USs. The focus is solely on the actions and resources, simplifying the US to its core components necessary for conflicts analysis.

\end{itemize}
\end{definition}
\begin{definition}[\textbf{Conflict}]
	Conflict refers to situations where two USs try to:	 
	\begin{itemize}
		\item delete a resource which another US are using
		\item delete a resource which another US also wants to delete
		\item create a resource which another US prohibits
	\end{itemize}
	$Notation$. Lowercase identifiers refer to single elements, and uppercase identifiers denote sets. 
	\\A user story is a 1-tuple $us = \langle m\rangle $ where:
	\begin{itemize}
		\item A main $m$ is define a 6-tuple: \\\\$m = \langle P,A,E,Tr,Ta,Co\rangle $ \\\\where:
		
	\begin{itemize}
		\item $P = \{ p_1,p_2,...\} $ is a set of personas.
		
		\item $A = \{ a_1,a_2,...\} $ is a set of actions.
		
		\item $E = \{e_1,e_2,...\}$ is a set of entities.
		
		\item $Tr = \{(p_1,a_1),(p_2,a_2),...\}$ is a set of triggers references, each begin a pair of persona and action.
		
		\item $Ta = \{(a_1,e_1,R_1),(a_2,e_2,R_2),...\}$ is a set of targets references, each begin a triple of action, entity, and action-annotations $R$.
		
		\item $Co = \{ (e_{c1},e_{c2},R_{c1}),(e_{c*},e_{c*},R_{c2}),... \}$ is a set of contains references, each begin a triple of two entities and action-annotations R.
		
		\item $R = \{"preserve", "create", "delete", "forbid"\}$ are the action-annotations applied to actions.
	\end{itemize}
	
	\end{itemize}
	To denote a syntactic operator, we add the subscript
	“syn”; for instance, $=_{syn}$ is syntactic equivalence which introduced by Lucassen et al. \cite{lucassen2016improving}.\\ Consider two USs:\\\\ $us_1 = \langle m_1\rangle $ where $m_1 = \langle p_1,a_1,e_1,tr_1,ta_1,co_1 \rangle$ \\\\$us_2 = \langle m_2\rangle$ where $m_2 = \langle p_2,a_2,e_2,tr_2,ta_2,co_2 \rangle$ and $co_2 = (e_{c1},e_{c2},R_{c1})$\\\\
	$us_1$ causes a conflict if:
	\begin{enumerate}
		\item The entity $e_1$ is an exact redundant of entity $e_2$, formally:\\ $isRedundant(e_1,e_2) \leftrightarrow e_1 =_{syn} e_2$ and one of the following conditions holds:\\
		\begin{enumerate}
			\item ($ta_1 = (e_1,a_1,"preserve")$ and $ta_2 = (e_2,a_2,"delete")$) or \\($ta_1=(e_1,a_1,"delete")$ and $ta_2 = (e_2,a_2,"preserve")$)\\
			
			\item ($ta_1 = (e_1,a_1,"create")$ and $ta_2 = (e_2,a_2,"forbid")$) or \\($ta_1 = (e_1,a_1,"forbid")$ and $ta_2 = (e_2,a_2,"create")$)\\
			
			\item $ta_1 = (e_1,a_1,"delete")$ and $ta_2 = (e_2,a_2,"delete")$
		\end{enumerate}
		
		\item The entity $e_1$ is an exact redundant of  $e_{c1}$, formally:\\ $isRedundant(e_1,e_{c1}) \leftrightarrow e_1 =_{syn} e_{c1}$ and one of the following conditions holds:\\
		\begin{enumerate}
			\item ($ta_1 = (e_1,a_1,"preserve")$ and $co_2 = (e_{c1},e_{c2},"delete")$) or \\($ta_1 = (e_1,a_1,"delete")$ and $co_2 = (e_{c1},e_{c2},"preserve")$)\\
			
			\item ($ta_1 = (e_1,a_1,"create")$ and $co_2 = (e_{c1},e_{c2},"forbid")$) or \\($ta_1 = (e_1,a_1,"forbid")$ and $co_2 = (e_{c1},e_{c2},"create")$)\\
			
			\item $ta_1 = (e_1,a_1,"delete")$ and $co_2 = (e_{c1},e_{c2},"delete")$
		\end{enumerate}
	\end{enumerate}
	 
	To comprehensively assess conflicts, it is important to consider not only the textual content but also the functional relevance of each action over entities within the USs. By categorising actions into four groups, conflicts that are not immediately apparent through a simple text comparison can be uncovered, thereby reducing the time required to manually search for conflicts.
\end{definition}	
\subsubsection*{Design Phases}\label{conflict_design_phases}
To provide a comprehensive overview of the design phases, this section explains each step of the process, from initial setup to final evaluation, using practical examples.

Listing \ref{list:conflict_pseudocode} is the pseudocode that describes how to analyse the conflicts in a particular abstraction and explains the logic and sequence of steps.
\newpage
\begin{MyListing}
	\scriptsize
	\hrule
	\begin{flushleft}
	 %\includegraphics[scale=0.8]{Listing/conflict_pseudocode}
	 1. \textbf{funct} conflict-analysis(dataset: Dataset)\\
	 2. \hspace{12pt}\textbf{var} conflictPairs \textbf{←} Null\\
	 3. \hspace{12pt}\textbf{for} each uS\_a \textbf{in} dataset \textbf{do}	\\
	 4. \hspace{20pt}\textbf{var} mainPart\_a, benefitPart\_a \textbf{←} DivideIntoMainAndBenefitParts(uS\_a)\\
	 5. \hspace{20pt}\textbf{var} action\_a \textbf{←} GetAction(mainPart\_a)\\ 
	 6. \hspace{20pt}\textbf{var} aN\_a \textbf{←} GetActionAnnotationFromDB(action\_a)\\
	 7. \hspace{20pt}dataset  \textbf{←} AddActionAnnotationIntoDataset(aN\_a)\\
	 8. \hspace{20pt}\textbf{var} entity\_a \textbf{←} GetEntity(mainPart\_a)\\
	 9. \hspace{20pt}\textbf{for} each uS\_b \textbf{in} dataset do\\
	 10. \hspace{26pt}\textbf{var} mainPart\_b, benefitPart\_b \textbf{←}  DivideIntoMainAndBenefitParts(uS\_b)\\
	 11. \hspace{26pt}\textbf{var} action\_b \textbf{←} GetAction(uS\_b)\\ 
	 12. \hspace{26pt}\textbf{var} aN\_b \textbf{←} GetActionAnnotationFromDB(action\_b)\\
	 13. \hspace{26pt}dataset  \textbf{←} AddActionAnnotationIntoDataset(aN\_b)\\
	 14. \hspace{26pt}\textbf{var} entity\_b \textbf{←} GetEntity(uS\_b)\\
	 15. \hspace{26pt}\textbf{var} containEntity\_b \textbf{←}  GetEntityFromContains(uS\_b)\\
	 16. \hspace{26pt}\textbf{if} HasConflict(aN\_a, aN\_b) \textbf{==} True \textbf{then}\\
	 17. \hspace{45pt}\textbf{if} entity\_a \textbf{==} entity\_b \textbf{or} entity\_a \textbf{==} containEntity\_b \textbf{then}\\
	 18. \hspace{55pt}conflictPairs \textbf{+=} \textbf{new} AddConflictPair(uS\_a, uS\_b)\\
	 19. \hspace{6pt}\textbf{Return} ReportAllConflicts(conflictPairs)\\
\end{flushleft}
\hrule
\caption{The pseudocode describes how to analyse the conflicts in a specific abstraction}\label{list:conflict_pseudocode}
\end{MyListing}
\subsubsection*{Data Structure of USs}\label{conflict_design_step_0}
As primary input, we receive a graph-based model generated by the Doccano tool presented by Mosser et al., which represents the refined and annotated dataset for the recognition of \emph{entities}, \emph{actions}, \emph{persona} and \emph{benefits} of USs \cite{arulmohan2023extracting}.

The datasets have the JSON format, the structure of which is very important in the Java classes \textit{USPartExtractor}, and \textit{ActionsAnnotationsCreator}. Therefore, understanding the JSON format provided is needed for the further steps.

Each JSON file for a backlog dataset contains a JSON-array in which each US entry is defined as a JSON-object. Listing \ref{list:conflict_desing_json_format} illustrates the format used for the US JSON-object.

\begin{MyListing}
	\centering
	\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/conflict_json_format.json}
	\caption{The format of US JSON-object in JSON file}\label{list:conflict_desing_json_format}
\end{MyListing}
A US JSON-object in this format contains the following elements:
\begin{itemize}
	\item ID: Is the actual US identifier
	
	\item Text: Is the complete text from US
	
	\item Entities: is an array of JSON-objects with the following elements:
	\begin{itemize}
		\item ID: Serves as a reference number for the entry.
		
		\item Label: Is the name of the entry, which can be "PID", "Persona", "Entity", "Action", or "Benefit".
		
		\item Start\_offset: Refer to the position of the first character of the word within the entire text.
		
		\item End\_offset: Is the position of the last character of the word within the entire text.
	\end{itemize}
	\item Relations: Is an array of JSON-objects with the following entries:
	\begin{itemize}
		\item ID: Serves as a reference number for the entry.
		
		\item From\_ID: Is the entry ID of the first element that occurs in the relation.
		
		\item To\_ID: Is the entry ID of the second element that occurs in the relation.
		
		\item Type: Is the type of relation, which can be "Triggers", "Targets", or "Contains".
	\end{itemize}
	As relation, each \emph{Persona} is linked to each \emph{Action} as \texttt{Triggers} relation, each \emph{Action} is linked to each \emph{Entity} as \texttt{Targets} relation and each \emph{Entity} is linked to each \emph{Entity} implying a \texttt{Contains} relation.
\end{itemize}
\subsubsection*{Step 1: Split Elements into Main and Benefit Parts}\label{conflict_design_step_1}
Since the original JSON format does not distinguish between the elements belonging to the main or the benefit parts, this step brings relief and more accuracy, which is useful when processing elements in certain parts of the USs.

For this reason, we use the class \texttt{USPartExtractor}, which creates a new JSON format in which all elements referring to a US JSON-object are extracted from the primary input and stored in the appropriate part of US.

Listing \ref{list:json_USPartExtractor} illustrate the format of JSON file generated by USPartExtractor class.
\newpage
\begin{MyListing}
	\centering
	\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/json_USPartExtractor.json}
	\caption{The new format generated by USPartExtractor class}\label{list:json_USPartExtractor}
\end{MyListing}
If the elements in a relation come from both the main and the benefit part, we store them in the \texttt{Mix} JSON-object. As the conflict in the benefit part is not taken into account in our approach, we exclude the elements that originate from the benefit and the mix part.
\subsubsection*{Step 2: Adding Action-Annotations}
In order to facilitating conflicts analysis, we first need to translate each verb that refers to a US into four distinct categories, namely "preserve", "create", "delete", and "forbid". For this reason, we collect all verbs and the corresponding action-annotations in action-annotation database reference.

Secondly, we use the \texttt{VerbFiner} class to search the reference database for the verb associated with a US and return the corresponding action-annotation/s. Thirdly, for each US JSON-object, we add a JSON object labelled "Action-Annotations" to the Main JSON-object using the \texttt{ActionsAnnotationsCreator} class, which consists of two elements:
\begin{itemize}
	\item Targets Action-Annotation: This is an array of targets relations, where each element is a triple of "action", "entity" and additionally one or more "action-annotation/s" separated by "\texttt{;}".
	
	\item Contains Action-Annotation: This is an array of contains, where each element is a triple of "action", "entity" and additionally one or more "action-annotation/s" separated by "\texttt{;}".
\end{itemize}
\begin{example}
Listing \ref{list:json_ActionsAnnotationsCreator} illustrates an example of adding elements in two US created by the ActionsAnnotationsCreator class, which contains all the elements we need for the conflicts analysis.

In this example, we see that in user\_story\_13 the verb "apply" in "Target Action-Annotation" is translated into two action-annotations, namely "create" and "preserve" (third element of the array), and the verb "remove" in "Target Action-Annotations" of user\_story\_14 is translated into the action-annotation "delete".

We also see that "Contain Action Annotations" is an empty array and is depicted with "[]".
\end{example}
\begin{MyListing}
	\centering
	\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/json_ActionsAnnotationsCreator.json}
	\caption{Example of adding action-annotations to the individual verbs}\label{list:json_ActionsAnnotationsCreator}
	\end{MyListing}
\subsubsection*{Step 3: Analysing Conflicts and Creating Report}
After we have inserted the action-annotations into the US JSON-object, we can now analyse the conflicts and simultaneously report the founding conflicts by using the \texttt{ReportMaker} class. The steps involved in this process are as follows:
\begin{enumerate}
	\item Create text and JSON formats for reporting: To report a set of datasets in a single file, we create two "consolidated conflict reports", one in text format and one in JSON format. We also create two types of reports for individual datasets (one in text format and one in JSON format). It is also worth noting that creating the JSON format facilitates the conflicts analysis evaluation process.
	
	\item Iterate through each dataset and analysing conflicts: We iterate over the USs to identify conflicts by comparing the action-annotations and applying defined criteria into one US and another.
	
	If there is a potential conflict pair, we store this pair and its information such as US\_ID, conflict reason, text of USs, affected entity, conflict actions to the report. 
	
	\item Create summary table (only applicable for the text report): A summary table of potential conflicts between USs is created at the top of the textual report files and marked with an "x" if a conflict exists between individual US-pairs.
	
	\item Generate and write reports: It writes the conflict information, including US\_ID, actions, conflict reason and elements highlighted with "\#" in the main parts, to the report files.
\end{enumerate}
\begin{example}
In this example, we apply the conflicts analysis to the project G03\_loudoun. As a result, we get the generated text report consisting of a conflict pair between user\_story\_327 and user\_story\_328 as shown in Listing \ref{list:conflict_textual_report_sample}, and the parts of the report has been marked and noted.
\begin{MyListing}
	\paragraph{}
	\centering
	%\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/TextualReportSample.txt}
	\includegraphics[scale=0.7]{Listing/conflict_textual_report_sample.png}
	\caption{Example of generated textual report consist of one conflict pair}\label{list:conflict_textual_report_sample}
\end{MyListing}
\end{example}
\subsubsection*{Step 3: Evaluation}
In this step, we collect all potential conflicts we have found in an Excel file called ‘Conflict\_Evaluation’ to compare the result provided by the tool with the ground truth. See the section \ref{conflict_evaluation} for a comprehensive explanation.



\input{Section/Conflict_Implementation}