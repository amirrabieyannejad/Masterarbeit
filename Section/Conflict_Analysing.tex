\section{Analysing Conflict}\label{conflict}
In software development, especially in agile methods, conflict analysis is an important task to ensure the coherence and functionality of the system to be developed. A conflict is defined as a inconsistency that arises when two or more requirements, often encapsulated as USs, contradict each other. This section will introduce and define conflict analysis, focusing on the concept of \textit{content inconsistency} between USs.

The main objective of this analysis is to rationalise the software development workflow by semantically identifying conflicts between the USs within the backlog of a project.

A conflict of requirements arises when two or more USs show contradictions or inconsistencies. This can manifest itself in various forms, e.g. in the manipulation of the same resource by several USs at the same time, in overlapping functions or in conflicting conditions.

\begin{example}
	Considering following USs:\\\\
	user\_story\_13: "\#G03\# As a Staff member, I want to Apply a Hold, so that I can prevent progression through the workflow or other actions in the system until the issue is resolved."\\\\
	user\_story\_14: "\#G03\# As a Staff member, I want to Remove a Hold, so that I can allow progression through the workflow or other actions in the system now that the issue has been resolved."\\\\
	In this example, user\_story\_14 deletes a resource that is used by user\_story\_13. This means that user\_story\_13 cannot be applied at all if user\_story\_14 is executed first, which leads to a conflict between these USs.
\end{example}

In section \ref{conflict_requirement}, we present the requirements and functional needs that serve as input for the design phase in order to fulfil the requirements. In section \ref{conflict_desing} we explain the design decisions of the workflow shown in figure \ref{fig:conflict_operational_flow} and explain how the architecture is structured. 

\subsection{Requirements}\label{conflict_requirement}
In order to accomplish the analysis of conflicts in USs we try to address following functional requirements:
\begin{itemize}
	
	\item As a user, I want to perform semantic analysis on user stories within a specified project backlog, so that I can identify and address conflicts effectively.
	
	\item As a user, I want a report on the US-pairs that are conflicting in the main parts so I can change them if needed.
	
	\item As a user, I want to apply a filter to the conflict report to only show US-pairs that have the same resource (as entity) with different verbs (as action), so that the verbs are semantically contradictory (e.g. one US deletes a resource that another US is using, or deleting or one US creates a resource that another US prohibits).
	
	%\item As a user, I want to mark found redundancy clauses as Triggers with a hash symbol (\#) and show those that have a redundancy in \enquote{Persona} (as a noun) and \enquote{Action} (as a verb) entries, so that I can better see if the persona in is also recognised as a redundancy.
	
	%\item As a user, I want to mark the containers (as Contains) with a hash symbol (\#) and display found resources as conflict element (as noun), so that I can better see whether the contained entity is also recognised as a conflict.
	
	\item As a user, I would like to have a conflict report that shows founded US texts in US-pairs and adds a hash symbol (\#) at the beginning and end of conflicting verbs and a noun (as a resource) as a marker, so that I can better recognise the verbs and noun that conflict in US-pairs.
	
	\item As a user, I want to see how many conflict US-pairs have been created in the main parts of the USs within a backlog, so that I can summarise conflict US-pairs founded on this basis for further statistical purposes.
	
	\item As a user, I want a table at the top of the conflict report that lists the US-pairs in conflict, so that I can quickly see all the US-pairs that have been founded.
	
\end{itemize}
To judge the operation of a system, we define following non-functional requirements:
\begin{itemize}
	\item Testability: The system should support automated test procedures to ensure that semantic analysis and conflict detection work correctly. It should include comprehensive test cases covering different scenarios, including edge cases, to verify the accuracy and reliability of conflict detection.
	
	\item Documentation: The system should include detailed documentation covering all aspects of functionality and setup. User manuals, API documentation and troubleshooting guides should be provided. 
	
	\item Performance: The system should perform the conflict analysis within a reasonable time frame, even with large project backlogs. It should be optimised so that it can process large volumes of data without any significant loss of performance.
	
	\item Scalability: The system should be scalable to handle an increasing the number of USs and larger project backlogs.
		
\end{itemize}

\subsection{Design}\label{conflict_desing}
This section describes the operational flow and architectural considerations that underpin the framework.
\subsubsection*{Design Overview}
To address the requirements specified in Section \ref{conflict_requirement}, our system used the backlogs labelled with Doccano tool\footnote{https://github.com/ace-design/nlp-stories} generated by Mosser et al. as the primary input\cite{arulmohan2023extracting}.

To conduct conflict analysis, a one-time preparatory phase is needed to categorize the verbs in USs of backlog into four categories. Once this is done, conflict analysis can be applied to the USs using these categories and specific criteria.

Once the conflict analysis has been applied, a comprehensive report is created that contains information regarding conflict pairs in both a textual and a tabular form.

Finally, a conflict assessment phase is initiated for further statistical purposes.

Figure \ref{fig:conflict_operational_flow} illustrates how each step in this sequence is interconnected, with the output of one step feeding directly into the next. This diagram effectively demonstrates the toolchain and process workflow, highlighting how each step transforms artefacts and contributes to the overall objective of conflict detection.
\begin{figure}[h]
	\centering 
	\includegraphics[scale=0.65]{conflict_operational_flow}
	\caption{Step-by-step visualisation of the tool chain and its inputs and outputs}\label{fig:conflict_operational_flow}
\end{figure}
\paragraph{One-Time-Phase: Creating Database for annotated Verbs}In this phase, each verb should be classified using the VerbNet\footnote{\href{https://verbs.colorado.edu/verbnet}{https://verbs.colorado.edu/verbnet}} classification. Finally, each verb class annotated into four categories, namely \textit{Create, Delete, Preserve, or Forbid} (from now on) called \textit{action-annotation}. 

To validate the action annotations, a personal judgement is made for each verb by three evaluators, so that each person reviews the action annotations for each verb and comments their own action annotation. We then collect all the personal judgements and combine the action annotations for each verb.
%\paragraph{Translating the JSON-Format of the Primary Input}\label{conflict_workflow_preparing_json_format}
%Since the annotated USs in the original JSON files did not split entries such as "Entity", "Action", "Text", "Targets" and "Contains", it is not clear which element belongs to which part of the USs (main or benefit part), which leads to possible ambiguities.

%Accordingly, we use a class called \textit{USPartExtractor} that separates entries based on their occurrence in both the main and benefit parts of the USs. It also specifies an identifier to assign a unique identifier to each US, which is stored in a JSON object called \textit{"US\_Nr"}. 

%These additions improve the system's ability to distinguish and process individual USs within the analytical pipeline.
\paragraph{Conflict Analysis and Extraction of text reports} Creating a text report aims to find conflicts between USs and highlight important information, such as identifying potentially conflict pairs, the conflict reason, the resource (as noun) affected by actions (as verbs) causing the conflict, the texts of the main parts with the affected elements marked with \# and a tabulation of the potentially conflicting pairs.

\paragraph{Evaluating the reports} Once we have created the reports, we can now assess the correctness of the US-pairs reported as conflicts, i.e. whether the reported US-pairs really cause a conflict.

\subsubsection*{Software Architecture}\label{conflict_architectur}
In this section, we present the basic structures of our workflow and the discipline of creating such structures. Each structure comprises software elements, relations among them, and properties of both.
\begin{itemize}
	\item Annotated USs with Doccano Tool\footnote{https://github.com/doccano/doccano}: Mosser et al. used publicly available requirements from Dalpiaz et al.\cite{Dalpiaz2018} consisting of 19 product backlogs and 1,458 USs. The dataset is a raw archive of 19 text files, each containing one US per line. 
	
	As there were no public expert-based annotations, Mosser et al. manually annotated the dataset using the Doccano tool for \textit{Named Entity Recognition}. Labels included persona, action, entity, benefit part and relations such as triggers, targets, and contains based on their domain meta-model.
	
	As artefact we receive a graph-based model with JSON format, which represents the refined and annotated dataset for the recognition of \emph{entities}, \emph{actions}, \emph{personas} and \emph{benefits} of USs \cite{mosser2022modelling}.
	
	\item Eclipse as IDE\footnote{https://eclipseide.org/}: Eclipse is an integrated development environment (IDE) used in computer programming. It contains a base work workspace and an extensible plug-in system for customizing the environment.
	
	\item VerbNet as Verb Lexicon Resource\footnote{https://verbs.colorado.edu/verbnet/}: VN is the largest on-line network of English verbs that links their syntactic and semantic patterns. It is a hierarchical, domain-independent, broad-coverage verb lexicon with mappings to other lexical resource, such as WordNet\footnote{https://wordnet.princeton.edu/}, PropBank \footnote{https://propbank.github.io/}, and FrameNet \footnote{http://framenet.icsi.berkeley.edu/}. 
	
	VerbNet is organized into verb classes extending Levin (1993) classes through refinement and addition of subclasses to achieve syntactic and semantic coherence among members of a class. Each verb class in VN is completely described by thematic roles, selectional preferences of the arguments, and frames consisting of a syntactic description and a semantic representation with subevent structure patterned on the Dynamic Event Model of Pustejovsky and Moszkowicz and Pustejovsky\cite{kipper2006extending}.
	
	\item USPartExtractor Class: This class is part of the \textit{org.backlogconflict.code .preparation} package and is a key component of the software architecture designed for transforming primary input datasets in the specific JSON format. It separates elements based on their occurrence in both the main and benefit parts of the USs.
	
	This process simplifies subsequent tasks for editing, analysing and conflict resolution by providing a clear structure for the USs and their components. The separation of main and benefit parts and the assignment of unique identifiers improves the manageability and traceability of USs within the system.
	
	\item Action Annotation Reference Database: This database is essential for identifying conflicts between USs, especially conflicts arising from actions over common entities ( as resources). To achieve this, we categorise verbs into four different groups namely \textit{Preserve, Delete, Create, and Prohibit}.
	
	The main purpose of the action Annotation reference database is to facilitate the translation of actions (in the form of verbs) found in USs into corresponding action-annotations. This process involves several important steps:
	\begin{enumerate}
		\item Collection of Actions: We collect all actions (represented as verbs) from existing datasets and compile them into a CSV file. This file serves as comprehensive reference database.
		
		\item Contextual Translation: Each verb in the CSV file is translated into the corresponding action-annotations related to its VerbNet class. 
		
		\item Personal Judgement: To validate the action annotations, three evaluators individually assess each verb. Each evaluator reviews the annotations and provides their own comments. We then gather these individual assessments and combine them to finalize the action annotation reference database for each verb.
	\end{enumerate}
	
	\item VerbFinder Class: The \texttt{VerbFinder} class is an essential component within the \textit{org.backlogconflict.code.preparation} package, designed to interface with the action annotation database and facilitate the process of mapping verbs to their corresponding action annotations. 
	
	\item ActionsAnnotationsCreator class : This class is a component within the \textit{org.henshin. backlogconflict.code.preparation} package. Its primary function is to improve the extraction of Parts of US process by incorporating action annotations into the JSON dataset. 
	
	The class adds entries that consist of a set of triples: "action", "entity", and "action-annotations". These action-annotations are sourced from the reference database, which ensures that conflict detection and resolution are consistent and accurate. The matching process is done using the VerbFinder class. 
	
	\item ReportMaker Class: This class developed within the \textit{org.backlogconflict .code.report} packages, its primary function is to identify conflicting US-pairs based on specific criteria and generate comprehensive reports on these conflicts. It performs the following key tasks:%This class provides detailed information on the nature of the conflicts, making it an invaluable tool for maintaining system coherence and resolving inconsistencies. 
	\begin{enumerate}
		\item Identification of Conflict US-pairs: The class analysis USs to identify pairs that conflict based on predefined criteria. These criteria including conflicting actions, or inconsistencies in the USs.
		
		\item Detailed Conflict Reporting: Once conflicts are identified, the class generates detailed reports. These reports contain essential information such as the affected entity(as resource), potential conflicted actions, conflict reason, and the texts of main parts of the USs with marked elements with hash symbol (\#).
		
		\item Tabular Summary: In addition to detailed conflict descriptions, the class also produces a tabular summary of all identified conflict pairs in a backlog, providing a quick overview of the conflict US-pairs.
	\end{enumerate}

	
\end{itemize}
Figure \ref{fig:conflict_technical_implementation} shows the architectural composition, highlighting the integral components and their user interface and artefacts.
\begin{figure}[h]
	\centering 
	\includegraphics[scale=0.6]{conflict_technical_implementation}
	\caption{Design phases}\label{fig:conflict_technical_implementation}
\end{figure}
Regarding conflict, some definitions are clarified:
\begin{definition}[\textbf{Customized User Story}]
	In order to apply conflict analysis to the backlog, a customized user story is defined, which consists solely of the main part that collectively describes what the user wants and the consequences of this need for the resources.
\begin{itemize}
	\item The \textit{main part} is essential as it clearly and concisely summarizes the persona, the intended functionality, and the resources required to perform the action. This part usually follows the format: \textit{"As a [persona], I want [actions over entities]."}
	
	In this customized US, the intended functionality, which describe the action that the persona wants to perform or the function they need, will be translated into four annotations: "create," "delete", "preserve", or "forbid". These annotations serve to standardize the actions for conflict analysis:
	
	\begin{itemize}
		\item \textbf{Create:} This action-annotation describes the introduction or addition of a new entity within the system. For example, the action "apply" in US \textit{"As a staff member, I want to apply for a hold."} is annotated with "create" action.
		
		\item \textbf{Delete:} This action-annotation indicates the removal or elimination of an entity from the system. For example, the action "remove" in US \textit{"As a staff member, I want to remove a hold."} is annotated with "delete" action.
		
		\item \textbf{Preserve:} This action-annotation involves safeguarding, or using an existing entity without alterations. For example, the action "browse" in US \textit{"As a researcher, I want to browse through files in a collection."} is annotated with "preserve" action.
		
		\item \textbf{Forbid:} This action-annotation specifies prohibiting certain actions on an entity. For example, the action "restrict access" in US \textit{"As a collection curator, I want to restrict access to my collection or items to duke IP addresses."} is annotated with "forbid" action.
	\end{itemize}
	
	Specifying the resources required to perform the action helps with planning and resource allocation, ensuring that the development team is aware of the tools, technologies, and time required. This includes identifying all entities involved in the actions described and their relationships.
	
	In other words, with respect to the action, we translate it into the aforementioned action-annotations for conflict analysis. This translation standardizes the actions, making it easier to identify and resolve conflicts between USs.
	
	It is worth noting that in this form of US, the benefit part is not considered as part of the structure of USs. The focus is solely on the actions and resources, simplifying the US to its core components necessary for conflict analysis.

\end{itemize}
\end{definition}
\begin{definition}[\textbf{Conflict}]
	Conflict refers to situations where two USs try to:	 
	\begin{itemize}
		\item delete a resource which another US are using
		\item delete a resource which another US also wants to delete
		\item create a resource which another US prohibits
	\end{itemize}
	$Notation$. Lowercase identifiers refer to single elements, and uppercase identifiers denote sets. 
	\\A user story is a 1-tuple $us = \langle m\rangle $ where:
	\begin{itemize}
		\item A main $m$ is define a 6-tuple: \\\\$m = \langle p,A,E,Tr,Ta,Co\rangle $ \\\\where:
		
	\begin{itemize}
		\item $p$ is the persona.
		
		\item $A = \{ a_1,a_2,...\} $ is a set of actions.
		
		\item $E = \{e_1,e_2,...\}$ is a set of entities.
		
		\item $Tr = \{(p_1,a_1),(p_2,a_2),...\}$ is a set of trigger references, each begin a pair of persona and action.
		
		\item $Ta = \{(a_1,e_1,R_1),(a_2,e_2,R_2),...\}$ is a set of target references, each begin a triple of action, entity, and action-annotations $R$.
		
		\item $Co = \{ (e_{c1},e_{c2},R_{c1}),(e_{c*},e_{c*},R_{c2}),... \}$ is a set of contain references, each begin a triple of two entities and action-annotations R.
		
		\item $R = \{preserve, create, delete, forbid\}$ are the annotations applied to actions.
	\end{itemize}
	
	\end{itemize}
	To denote that a syntactic operator, we add the subscript
	“syn”; for instance, $=_{syn}$ is syntactic equivalence which introduced by Lucassen et al. \cite{lucassen2016improving}.\\ Consider two USs:\\\\ $us_1 = \langle m_1\rangle $ where $m_1 = \langle p_1,a_1,e_1,tr_1,ta_1,co_1 \rangle$ \\\\$us_2 = \langle m_2\rangle$ where $m_2 = \langle p_2,a_2,e_2,tr_2,ta_2,co_2 \rangle$ and $co_2 = (e_{c1},e_{c2},R_{c1})$\\\\
	$us_1$ causes a conflict if:
	\begin{enumerate}
		\item The entity $e_1$ is an exact redundant of entity $e_2$, formally:\\ $isRedundant(e_1,e_2) \leftrightarrow e_1 =_{syn} e_2$ and one of the following conditions holds:\\
		\begin{enumerate}
			\item $ta_1 = (e_1,a_1,"preserve")$ and $ta_2 = (e_2,a_2,"delete")$
			
			\item $ta_1 = (e_1,a_1,"create")$ and $ta_2 = (e_2,a_2,"forbid")$
			
			\item $ta_1 = (e_1,a_1,"delete")$ and $ta_2 = (e_2,a_2,"delete")$
		\end{enumerate}
		
		\item The entity $e_1$ is an exact redundant of  $e_{c1}$, formally:\\ $isRedundant(e_1,e_{c1}) \leftrightarrow e_1 =_{syn} e_{c1}$ and one of the following conditions holds:\\
		\begin{enumerate}
			\item $ta_1 = (e_1,a_1,"preserve")$ and $co_2 = (e_{c1},e_{c2},"delete")$
			
			\item $ta_1 = (e_1,a_1,"create")$ and $co_2 = (e_{c1},e_{c2},"forbid")$
			
			\item $ta_1 = (e_1,a_1,"delete")$ and $co_2 = (e_{c1},e_{c2},"delete")$
		\end{enumerate}
	\end{enumerate}
	 
	To comprehensively assess conflicts, it is important to consider not only the textual content but also the functional relevance of each action over entities within the USs. By categorizing actions into four groups, conflict that may not be immediately apparent through a simple text comparison can be uncovered, thereby reducing time consumed in finding conflicts manually.
\end{definition}	
\subsubsection*{Design Phases}\label{conflict_design_phases}
To provide a comprehensive overview of the design phases, this section explains each step of the process, from initial setup to final evaluation, using practical examples.
\subsubsection*{Data Structure}\label{conflict_design_step_0}
As primary input, we receive a graph-based model generated by the Doccano tool, which represents the refined and annotated dataset for the recognition of \emph{entities}, \emph{actions}, \emph{persona} and \emph{benefits} of USs \cite{arulmohan2023extracting}.

The datasets have the JSON format, the structure of which is very important in the Java classes \textit{USPartExtractor}, and \textit{ActionsAnnotationsCreator}. Therefore, understanding the JSON format provided is needed for the next steps.

Each JSON file for a backlog dataset contains a JSON-array in which each US entry is defined as a JSON-object. Listing \ref{list:conflict_desing_json_format} illustrates the format used for the US JSON object.
\begin{MyListing}
	\paragraph{}
	\hrule
	\centering
	\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/conflict_json_format.json}
	\caption{The JSON format of each US JSON object in JSON file}\label{list:conflict_desing_json_format}
	\hrule
\end{MyListing}
A US JSON object in this JSON format contains the following elements:
\begin{itemize}
	\item ID: Is the actual US identifier
	
	\item Text: Is the complete text from US
	
	\item Entities: is an array of JSON objects with the following elements:
	\begin{itemize}
		\item ID: Serves as a reference number for the entry
		
		\item Label: Is the name of the entry, which can be "PID", "Persona", "Entity", "Action" or "Benefit"
		
		\item Start\_offset: Refer to the position of the first character of the word within the entire text
		
		\item End\_offset: Is the position immediately after the last character of the word within the entire text
	\end{itemize}
	\item Relations: Is an array of JSON objects with the following entries:
	\begin{itemize}
		\item ID: Serves as a reference number for the entry
		
		\item From\_ID: Is the entry ID of the first element that occurs in the relation
		
		\item To\_ID: Is the entry ID of the second element that occurs in the relation
		
		\item Type: Is the type of relation, which can be "Triggers", "Targets", or "Contains"
	\end{itemize}
	As relation, each \emph{Persona} is linked to each \emph{Action} as \texttt{Triggers} relation, each \emph{Action} is linked to each \emph{Entity} as \texttt{Targets} relation and each \emph{Entity} is linked to each \emph{Entity} implying a \texttt{Contains} relation.
\end{itemize}
\subsubsection*{Step 1: Split Elements into Main and Benefit Parts}\label{conflict_design_step_1}
Since the original JSON format does not distinguish between the elements belonging to the main or the benefit part, this step brings relief and more accuracy, which is useful when processing elements in certain parts of the US.

For this reason, we use the class \texttt{USPartExtractor}, which creates a new JSON format in which all elements referring to a US JSON object are extracted from the primary input and stored in the appropriate part of US.

Listing \ref{list:json_USPartExtractor} illustrate the format of JSON file generated by USPartExtractor class.
\begin{MyListing}
	\paragraph{}
	\hrule
	\centering
	\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/json_USPartExtractor.json}
	\caption{The new JSON format generated by USPartExtractor class}\label{list:json_USPartExtractor}
	\hrule
\end{MyListing}
If the elements in a relationship come from both the main and the benefit part, we store them in the \texttt{Mix} JSON object. As the conflict in the benefit part is not taken into account in our approach, we exclude the elements that originate from the benefit and the mix part.
\subsubsection*{Step 2: Adding Action Annotations}
In order to facilitating conflict analysis, we first need to translate each verb that refers to a US into four categories, namely ‘preserve’, ‘create’, ‘delete’, and ‘ forbid’. For this reason, we collect all verbs and the corresponding action annotations in a database called "action annotation database".

Secondly, we use the \texttt{VerbFiner} class to search the database for the verb associated with a US and return the corresponding action annotation/s. Thirdly, for each US JSON object, we add a JSON object labelled ‘Action Annotations’ to the Main JSON object using the \texttt{ActionsAnnotationsCreator} class, which consists of two elements:
\begin{itemize}
	\item Targets Action Annotation: This is an array of ‘targets’, where each element is a triple of ‘action’, ‘entity’ and additionally one or more ‘action annotation’ separated by ‘\texttt{;}’.
	
	\item Contains Action Annotation:This is an array of ‘Contains’, where each element is a triple of ‘action’, ‘entity’ and additionally one or more ‘action annotation’ separated by ‘\texttt{;}’.
\end{itemize}

\begin{example}
Listing \ref{list:json_ActionsAnnotationsCreator} illustrates an example of adding elements in two US created by the ActionsAnnotationsCreator class, which contains all the elements we need for the conflict analysis.

In this example, we see that in user\_story\_13 the verb ‘apply’ in "Target Action Annotation" is translated into two action annotations, namely ‘create’ and ‘preserve’ (third elements of the array), and the verb ‘remove’ in "Target Action Annotations" of user\_story\_14 is translated into the action annotation ‘delete’.
\end{example}

\begin{MyListing}
	\paragraph{}
	\hrule
	\centering
	\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/json_ActionsAnnotationsCreator.json}
	\caption{Example of adding action annotations to the individual verbs}\label{list:json_ActionsAnnotationsCreator}
	\hrule
\end{MyListing}
\subsubsection*{Step 5: Report Evaluation}
The Evaluation class, part of the \textit{org.henshin.backlog.code.evaluation} package, was developed to determine the level of redundancy in USs based on JSON reports. This class provides methods to evaluate whether two USs are either fully or partially redundant, analysing different application components of these USs.

The evaluation process involves a complex logic to determine whether USs are redundant. This includes:
\begin{itemize}
	\item Checking whether the arrays are empty or contain similar elements.
	\item Comparing the individual elements in the arrays for both USs to determine if they fully match (full redundancy) or if they have some common elements (partial redundancy).
\end{itemize}
\begin{example}
	For the two US-pairs of dataset G03, we apply the evaluation class to determine whether there is redundancy in the main or benefit part, and if so, what type of redundancy is recognised(full or partially).\\\\
	As shown in Listing \ref{list:json_evaluation}, four entries are added to the JSON report, namely "Main Partially Redundant", "Benefit Part Fully Redundant",
	"Main Part Fully Redundant", "Benefit Partially Redundant" as "Status" which their value is whether true or false. 
	\begin{MyListing}
		\paragraph{}
		
		\centering
		%\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/TextualReportSample.txt}
		\includegraphics[scale=0.7]{Listing/json_evaluation.png}
		\caption{Example of generated entries in JSON report regarding evaluation of level of redundancy in main or benefit part}\label{list:json_evaluation}
		
	\end{MyListing}	
	
	In the case of user\_story\_12 and user\_story\_39, the entry "Benefit Partially Redundant" was marked as \textit{true}, which means that US-pair in benefit parts are partially redundant.
	
\end{example}
The class performs these checks by iterating through the JSON arrays of Triggers, Targets and Contains and comparing each element with those in the common sections to determine redundancy.


\input{Section/Conflict_Implementation}