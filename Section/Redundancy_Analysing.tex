\section{Analysing Redundancy}\label{redundancy}
% some explenation here about what will be explain here an why
%(Analyse von Redundanz als title und dann im Text Schreiben, dass es ein syntaktische Analyse ist
In this section, we present an approach for syntactically analysing redundancy using the CRF tool, the Henshin and the CDA tool.

In section \ref{redundancy_requirement} we present the requirements and functional needs that are used as input for the design phase to fulfil the requirements. In section \ref{desing} we explain the design decisions of the workflow shown in figure \ref{fig:design_phases} and explain how the architecture is structured and what the components and their classes look like. 
\begin{figure}[h]
	\centering 
	\includegraphics[scale=0.35]{sequence_diagram}
	\caption{Design phases}\label{fig:design_phases}
\end{figure} 

In Section \ref{redundancy_implementation} comes the implementation to show what we implemented and in Section \ref{redundancy_test} we show how we tested it. Finally, we apply our approach to 19 datasets of backlogs annotated with the CRF tool \footnote {https://github.com/ace-design/nlp-stories}. In Section \ref{redundancy_evaluation} we evaluate the results.
\subsection{Requirements}\label{redundancy_requirement}
In order to accomplish the analysis of redundancy in USs we try to address following requirements:
\begin{itemize}
\item As a member of a project group, I want to syntactically analyse USs that belong to a specific backlog, so that redundancies between USs can be recognise and manage accordingly.
\item As a member of a project group, I would like to have a collection of US-pairs as a report that syntactically have the same clauses in main and benefit parts of USs, so that I can change them if necessary.
\item As a member of a project group, I want to filter the report and only see the redundancy clauses that contain \enquote{Action} (as a verb) and \enquote{Entity} (as a noun) in US-pair, so that I can reduce the count of potential redundancy pairs in the report.
\item As a member of a project group, I want to mark found redundancy clauses with a hash symbol (\#) and show those that have a redundancy in \enquote{Persona} (as a noun) and \enquote{Action} (as a verb), which is called \enquote{Triggers}, so that I can better see if the persona in is also recognised as a redundancy.
\item As a member of a project group, I want to mark founded redundancy clauses with a hash symbol (\#) and show those that contain two \enquote{Entity}(as a noun), which is called \enquote{Contains}, so that I can better see whether the contained entity is also recognised as a redundancy.
\item As a member of a project group, I would like to have a redundancy report that shows founded US texts in US-pairs and adds a hash symbol (\#) at the beginning and end of the founded words as a marker, so that I can better see which words are redundant in US-pairs.
\item As a member of a project group, I want to see how many redundancy clauses were founded in each US-pair, so that I can aggregate each founded redundancy US-pair for further statistical purposes on that basis.
\item As a member of a project group, I want a table at the top of the redundancy report that lists the US-pairs and the number of redundancy clauses contained in each pair, so that I can quickly see all the US-pairs founded and the number of redundancy clauses. 
\item As a member of a project group, I want to know whether the redundancy clauses belong to the main or benefit part of the US, so that I can use it for further statistical purposes.
\end{itemize}
% here should explain what was the reiquirement and why

\subsection{Design}\label{desing}
% what are the design decisions of this workflow that I had at the beginning, then describe what happens step by step, what translation I made, what is the main design decision you made for this translation, what question and that is part of the design
%In Desing should be how the architecture is based on which components and what is my own component, what does it use, what does the component look like, what class is there, is the class design, so everything comes from the Desing chapter
In this section, the workflow process shown in figure \ref{fig:design_phases} is described step by step. It also explains which design decisions were made for this workflow and how the architecture is based on which components and classes.

To fulfil the requirements mentioned in \ref{redundancy_requirement}, we use the CRF tool \cite{mosser2022modelling} for the annotation of backlogs and the Henshin API \cite{arendt2010henshin} under Java programming language for the automatic generation of rules for each US in the backlog. Moreover, we use Henshin's CDA(conflict and dependency analysis) feature \cite{mens2007analysing} to automatically recognise redundancy US-pairs.\\\\
A detailed, step-by-step description of the workflow is given below:
\subsubsection*{CRF Tool}\label{workflow_crf}
As input, we receive a graph-based model generated by the CRF tool, which represents the refined and annotated dataset for the recognition of \emph{entities}, \emph{actions}, \emph{persons} and \emph{benefits} of USs \cite{mosser2022modelling}.

Mooser et al. have linked each \emph{Persona} to each \emph{Primary Action} as \emph{Trigger} relationships, each \emph{Primary Actions} to each \emph{Primary Entity} as \emph{Target} relationships and each \emph{Primary/Secondary Entity} to each \emph{Primary/Secondary Entity} implying a \emph{Contains} relationship\cite{arulmohan2023extracting}. As output we receive a JSON-file which contains all annotated USs separated by each backlogs.
\subsubsection*{Identifying USs in JSON-File}\label{workflow_nummerize_us}
Annotated USs in each JSON file have no identifier. To distinguish USs, we use a Python script called \textit{nummerise\_us.py} \footnote{https://github.com/amirrabieyannejad/USs\_Annotation/tree/main/Script/numberise\_us}, which receives JSON files as input and adds a JSON object named \enquote{US\_Nr} with an identifier as value (e.g. user\_story\_01) to each US and returns the JSON files as output.
\subsubsection*{Creating Ecore Meta-Model}\label{workflow_ecore}
To be able to create rules in Henshin, an Ecore (meta)-model should be available. Ecore is the core (meta)-model at the heart of the EMF (Eclipse Modelling Framework). It enables the formulation of other models by utilising its constructs.

Accordingly, we create an Ecore meta-model as shown in Figure \ref{fig:ecore_meta_model}, which is inspired by the meta-model shown in Figure \ref{fig:conceptual_metamodel} and corresponds to the JSON-objects in the JSON-file as follows:
\begin{itemize}
	\item \textit{Persona} as a class in the meta-model corresponds to the JSON-object \enquote{Persona} in the JSON-file.
	\item \textit{Entity} as an abstract class, from which \textit{Primary/Secondary Entity} inherits as a class in the meta-model, corresponds to the JSON-object \enquote{Entity}, which contains two JSON-arrays, namely \enquote{Secondary/Primary Entity} in the JSON-file.
	\item \textit{Action} as an abstract class and \textit{Primary/Secondary Action} as an inherited class in the meta-model correspond to the JSON-object \enquote{Action}, which contains two JSON-arrays, namely \enquote{Secondary/Primary Action} in the JSON-file.
	\item \textit{Benefit} as a class in the meta-model, which also has an attribute called \enquote{text} that corresponds to the JSON-object \enquote{Benefit} in the JSON-file.
	\item \textit{Story} as a class in the meta-model that contains text from US, which also has an attribute called \enquote{text} that corresponds to the JSON-object \enquote{Text} in the JSON-file.
	\item Abstract class \textit{NamedElement} has attribute \textit{name}, which Primary/Secondary Action/Entity inherit from it, which corresponds to the value of \textit{Primary/Secondary Action/Entity} in JSON-file.
	\item \textit{Edge} with the name \textit{triggers} between Persona and Primary Action in the meta-model, which corresponds to the JSON-array \enquote{Triggers}, where each JSON-array in it contains a pair, the first element corresponding to the \textit{Persona} and the second to the \textit{Primary Action}.
	\item \textit{Edge} named \textit{targets} between Primary/Secondary Action and Primary/Secondary Entity in the meta-model, which corresponds to the JSON-array \enquote{Targets}, where each JSON-array has a pair, the first element corresponding to \enquote{Primary/Secondary Action} and the second element corresponding to \enquote{Primary/Secondary Entity}.
	\item \textit{Edge} named \textit{contains} between Primary/Secondary Entity and itself in the meta-model, which corresponds to the JSON-array \enquote{Contains}, where each JSON-array in it has a pair where the first element corresponds to \enquote{Primary/Secondary Entity} and the second element corresponds to \enquote{Primary/Secondary Entity}.
\end{itemize}

\begin{figure}[h]
	\center
	\includegraphics[scale=0.5]{ecore_metamodel}
	\caption{Ecore meta-model inspired by Mosser et al. \cite{mosser2022modelling}}\label{fig:ecore_meta_model}
\end{figure} 
\subsubsection*{Creating Rules}\label{workflow_rule_creator}
With the identified USs in the the JSON-file, we generate rules with the Henshin package \textit{org.eclipse.emf.henshin.model.compact}, which is responsible for the creation of \textit{transformation rules} and their \textit{classes}, \textit{attributes}, \textit{edges} and annotates them with \textless\emph{Delete}\textgreater, \textless\textit{Create}\textgreater or\textless\textit{Preserve}\textgreater, which are crucial for the CDA tool to recognise the redundant pairs.
 
To generating rules we create a package named \textit{org.henshin.backlog.code.rule} and specially the class \textit{RuleCreator} which used following classes\footnote{https://wiki.eclipse.org/Henshin/Compact\_API}\label{compact_api}:
\begin{itemize}
\item \textit{org.eclipse.emf.henshin.model.compact.CModule}: CModule class can import elements from an Ecore file to use them in the transformation process responsible for linking the Ecore meta-model to the Henshin-file to be created.
\item \textit{org.eclipse.emf.henshin.model.compact.CRule}: Once we have a CModule, we can specify transformation rules with the CRule class and create them.
\item \textit{org.eclipse.emf.henshin.model.compact.CNode}: Now that we have a transformation rule, we want to fill this rule with nodes, edges and attributes. To create a node within a transformation rule, we need the CRule class. To create an edge we need to reference two nodes together. The default action when specifying a node, edge or an attributes is the \textless\emph{preserve}\textgreater action. We can also specify a different action when we create a node or an edge, for example \textless\emph{delete}\textgreater or\textless\emph{create}\textgreater.
\item org.henshin.backlog.code.rule.RuleCreator: We implement \textit{RuleCreator} class that creates a rule with annotated nodes, edges and attributes based on a JSON-file as input and a Henshin-file containing all rules as output, where each rule and its members(nodes, attributes, edges) correspond to the individual US and their JSON-objects/arrays in the JSON-file. 

The most important design decision of this class is the way nodes, attributes and edges are annotated in order to be able to apply conflict and dependency analysis (CDA) for rules stored as a henshin file.

We decided to annotate the \enquote{name} attribute of all Primary/Secondary Actions/Entities and their associated edges including \enquote{targets}, \enquote{triggers} and \enquote{contains} as \textless delete\textgreater action. 

The main goal is to increase the probability of identifying US-pairs characterised by matching names of \textit{action} nodes and \textit{entity} nodes in conjunction with an edge called \textit{targets}. This congruence serves as a basic criterion for identifying potentially redundant US-pairs and simplifies the process of redundancy detection in the context of US analysis.
\end{itemize}
\subsubsection*{Methods of the RuleCreator Class}
In this section, the methods of the RuleCreator class is described as follows:
\begin{enumerate}
	\item readJsonArrayFromFile: This method receives a JSON file as input. After reading, the JSON content is tokenised, parsed into a JSON array and the parsed JSON array is returned.
	\item assingCmodule: This method assign a CModule to a Ecore meta-model. It creates a new CModule object with the provided Henshin-file name, adds imports from the Ecore file, and returns the module.
	\item processJsonFile: It takes parsed JSON array as input and processes their attributes, such as persona, actions, entities, text and their edges, such as targets, triggers. Corresponding elements are created as output in a the Henshin transformation module (CModule).
	\item processRule: It takes the \enquote{US\_Nr} JSON-object as input and creates a new CRule with the name of unique US identifier in the CModule.
	\item processPersona: It receives as input the persona extracted from the JSON data and the associated CRule to create a new CNode representing the persona within the provided CRule and adds the attribute \enquote{name} with persona as value. Finally, the created CNode representing the persona is returned.
	\item processText: It receives as input US text extracted from JSON data and the associated CRule to create a new CNode representing the text within the provided CRule and adds the attribute \enquote{text} with US text as value. Finally, the created CNode representing the US text is returned.
	\item processActions: The processActions method is responsible for creating CNode objects that represent actions within the CModule. As parameters, it receives the JSON-object of the actions, the CNode-object representing the persona associated with the actions and the unique identifier of the US. Since the edge triggers only refer to the persona and the primary action, a new CNode is created for each primary action that represents the primary action within the provided CRule, an attribute \enquote{name} is added and an edge is created from the persona node to the primary action with the label \enquote{triggers}. For each secondary action, a new CNode is created to represent the action within the provided CRule and an attribute \enquote{name} is added to the action node.
	\item checkEntityIsTarget: It receives the name of the entity and the JSON-array with information about target edges. The method iterates through the JSON-array targets, which contains arrays that represent targets edges between actions and entities. It compares the targets entity with the specified entity. If there is a match, it returns true to indicate that the entity is a target.
	\item processEntities: It receives as parameters the JSON-object with information about the entities, the CRule object representing the US to which the entities belong and the JSON-array with information about the targets associated with the entities. The method checks whether primary/secondary entities are present, then creates a CNode for each primary/secondary entity and checks whether the entity is present in the target array. If this is the case, its attribute \enquote{name} is annotated for deletion. This method is used within the processContainsEdges method to determine whether an entity involved in a contains relationship is also a target of another entity.
	\item processContainsEdges: It receives the JSON-object to be processed, the JSON array with information about contains/target edges and the US identifier as parameters. It first checks whether both entities belong to contains edges. If both entities exist, an edge is created between them in CRule with the name \enquote{contains}. If one of the entities is a target of another entity (as specified in the targets array), the edge is annotated for deletion. If none of the entities is a target, the edge is annotated as \enquote{preserve}.
\end{enumerate}
Figure \ref{fig:rule_creator_methods} shows the sequence diagram of the RuleCreator methods.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.35]{RuleCreator_methods}
	\caption{Sequence diagram of the RuleCreator methods}\label{fig:rule_creator_methods}
\end{figure}
\subsubsection*{Conflicting and Dependency Analysis}
After the rules and the corresponding henshin file have been created by the RuleCreator class, we are now able to pass them to the conflict and dependency analysis (CDA) to find potential redundancy pairs.

Since the analysis of conflicts and dependencies related to the \textit{attribute} is not yet considered in the CPA API \footnote{https://wiki.eclipse.org/Henshin/conflict\_and\_Dependency\_Analysis}, we decided to use the user interface (UI) of the CPA extension of Henshin, which supports analysis of conflict and dependencies of rules through the interactive use of CPA.

To apply CDA to Henshin files, we just need to right-click on the Henshin file and select \textit{Henshin}\textgreater\textit{conflict and Dependency Analysis} from the context menu as shown in Figure \ref{fig:henshin_context_menu}.
\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{henshin_context_menu}
	\caption{Applying CDA to the selected Henshin file}\label{fig:henshin_context_menu}
\end{figure}
A user interface then appears, prompting to select the rule sets to be analysed and the type of analysis. We then select as \enquote{\textit{First}} and \enquote{\textit{Second} \textit{Rules}}, all rules related to USs. Additionally, as the type of analysis we select \enquote{\textit{conflicts}} as illustrated in Figure \ref{fig:select_rules}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{select_rules}
	\caption{CDA user interface: Selection of rules and type of analysis}\label{fig:select_rules}
\end{figure}

 On the next page of the CDA UI shown in Figure \ref{fig:select_granularity}, we specify the depth of analysis that we use with \enquote{\textit{Fine granularity}} when selecting \enquote{\textit{Create a complete result table}} and \enquote{\textit{Create an abstract result table}}. We choose \enquote{Fine granularity} as the depth of analysis due to the fact that it shows all conflict reasons for each conflicting rule pair.
 
 A conflict reason is a model fragment whose presence leads to a conflict. General conflict reasons result from different combinations of minimal conflict reasons\cite{cda_api}.
 \begin{figure}[h]
 	\centering
 	\includegraphics[scale=0.5]{select_granularity}
 	\caption{CDA user interface: Selection of report granularity}\label{fig:select_granularity}
 \end{figure}
 
 During the execution of the CDA analysis, the rule pairs is analysed and a conflict analysis is performed. Once the calculation is complete, the results are listed in the \enquote{CDA} -\textgreater \enquote{Result window}, as shown in Figure \ref{fig:cda_report}. The top entry shows the granularity, which in our case is \enquote{Fine}. These entries contain the rule pairs that conflict with each other. Each rule pair contains a number of conflict reasons.
  \begin{figure}[h]
 	\centering
 	\includegraphics[scale=0.5]{cda_report}
 	\caption{CDA report with fine granularity}\label{fig:cda_report}
 \end{figure}
 
 Figure \ref{fig:cda_report_in_project_dir} shows how the data is saved in the project tree view. The results directory is created in the directory containing the Henshin that was used for the analyses. The new folder name is the date and time at which the analysis was performed. In contrast to the \enquote{\textit{CDA/Results}} view, this folder contains all conflict reasons and atoms together in a rule pair directory.
  \begin{figure}[h]
 	\centering
 	\includegraphics[scale=0.5]{cda_report_in_project_dir}
 	\caption{Saving CDA results data in the project structure view}\label{fig:cda_report_in_project_dir}
 \end{figure}
 
 For each conflict reason, there is a \enquote{\textit{minimal-model.ecore}} file, that contains packages in which various conflict elements such as \enquote{attributes} and \enquote{references} (edges) are mapped together and displayed in different packages.
 
 Figure \ref{fig:minimal_model_packages} shows the representation of the conflicting attributes and references. An attribute has the property of changing the value and is represented by an arrow \enquote{-\textgreater}. The attribute from the first rule is separated from the second rule by an underscore, just as with the nodes.
  \begin{figure}[h]
 	\centering
 	\includegraphics[scale=0.5]{minimal_model_packages}
 	\caption{Representation of conflicting attributes and references in \textit{minimal-model.ecore} file}\label{fig:minimal_model_packages}
 \end{figure}
\subsubsection*{Extracting Textual Report}
To make the CDA report lightweight for the concerned group or individual, we need to extract the key information such as redundancy US-pair, redundancy clauses, number of redundancy clauses in each part or sentence (main or benefit part) and create a report as a text file containing the following information:
\begin{itemize}
	\item A table of potential redundant pairs with the number of total redundancy clauses.
	\item Founded potential redundant US-pairs
	\item Redundancy words and clauses of founded US-pairs
	\item Text of US-pairs whose redundancy words are marked with a hash symbol (\#).
	\item Parts of the sentence in which words and clauses are found.
\end{itemize}
Listing \ref{list:textual_report_sample} illustrates the format of the textual report. In this case, the report only contains one US-pair.

\begin{MyListing}
\paragraph{}
\hrule
\centering
\lstinputlisting[basicstyle=\ttfamily\footnotesize]{Listing/TextualReportSample.txt}
\caption{Example of generated textual report for two US-pair}\label{list:textual_report_sample}
\hrule
\end{MyListing}
In order to extracting a textual report associated with a specific backlog, we implement a class called \textit{ReportExtractor} within the package \textit{org.henshin.backlog.code.report}, which include the following classes form the package \textit{org.eclipse.emf.ecore}\footnote{https://download.eclipse.org/modeling/emf/emf/javadoc/2.7.0/org/eclipse/emf/ecore/}. These classes are important for reading the content of minimal-model.ecore:
\begin{itemize}
	\item org.eclipse.emf.ecore.resource.Resource: A resource of an appropriate type is created by a resource factory; a resource set indirectly creates a resource using such a factory. A resource is typically contained by a resource set, along with related resources.
	\item org.eclipse.emf.ecore.resource.ResourceSet: A resource set manages a collection of related resources and notifies you of changes to this collection. It provides a tree of content. A collection of adapter factories supports the search for an adapter via a registered adapter factory. 
	\item org.eclipse.emf.ecore.EObject: EObject is the root of all modelled objects, therefore all method names start with "e" to distinguish the EMF methods from the client methods. It provides support for the behaviour and functions that are common to all modelled objects.
	\item org.eclipse.emf.ecore.EPackage: A representation of the model object \enquote{EPackage}.
	\item org.eclipse.emf.ecore.EClassifier: A representation of the model object \enquote{EClassifier}.
	\item org.eclipse.emf.ecore.EClass: A representation of the model object \enquote{EClass}.
	\item org.eclipse.emf.ecore.EAttribute: A representation of the model object \enquote{EAttribute}.
	\item org.eclipse.emf.ecore.EReference:  A representation of the model object \enquote{EReference}.
	
\end{itemize}
\subsubsection*{Storing Redundancy Items into RedundancyItems Class}
The following classes were created to represent the extracted model object accordingly. All these classes are extensions of the class \textit{RedundancyItems}, which contains all extracted model object from minimal-model.ecore such as EClass, EAttribute or EReference:
\begin{itemize}
	\item PrimaryAction/SecondaryAction: Which has only saved the EClass specified by \enquote{Primary/Secondary Action} and the E-Attribute model object with the methods \textit{getType} to retrieve the saved EClass and \textit{getName} to retrieve the saved E-Attribute.
		\item PrimaryEntity/SecondaryEntity: Which has only saved the EClass specified by \enquote{Primary/Secondary Entity} and the E-Attribute model object with the methods \textit{getType} to retrieve the saved EClass and \textit{getName} to retrieve the saved E-Attribute.
		\item Targets: The EClass specified by \enquote{Primary/Secondary Action} as \textit{outgoing edge} and an E-Attribute model object as \textit{incoming edge} with \enquote{Primary/Secondary Entity}. The method \textit{getType} retrieve the stored EClass and method \textit{getName} retrieve the stored E-Attribute.
		\item Contains: The EClass specified by \enquote{Primary/Secondary Entity} as \textit{outgoing edge} and an E-Attribute model object as \textit{incoming edge} with \enquote{Primary/Secondary Entity}. The method \textit{getType} retrieve the stored EClass and method \textit{getName} retrieve the stored E-Attribute.
		\item Triggers: \item Contains: The EClass specified by \enquote{Persona} as \textit{outgoing edge} and an E-Attribute model object as \textit{incoming edge} with \enquote{Primary Action}. The method \textit{getType} retrieve the stored EClass and method \textit{getName} retrieve the stored E-Attribute.
		\item RedundantPair: Stores the identifier of the two created user stories as a redundant pair. It also saves the total number of redundancy clauses within the US-pair.
		\item TargetsPair: Stores effective value of \textit{Primary/Secondary Action} and \textit{Primary/Secondary Entity} in action and entity fields accordingly.
		\item ContainsPair: Stores effective value of \textit{Primary/Secondary Entity} as \textit{parent/child entity} due to the fact that parent entity is a containment of child entity.
		\item TriggersPair: Stores effective value of \textit{Persona} as a persona and \textit{Primary Action} as an action.
\end{itemize}
The calss RedundancyItems contains following methods which are crucial for class ReportExtractor:
\begin{itemize}
	\item isInCommonContains: This method is designed to determine whether a given entity (specified by its name) is part of a redundant pair listed in the Contains array of related user stories stored in a JSON file. As input, it receives the name of the entity for which we want to check whether it exists in a redundant pair. In addition, a list of redundant pair objects that represent pairs of entities where one entity contains the other. If there is a match with the parent entity, it returns the child entity and vice versa.
	\item isInCommonTargets: This method is responsible for determining whether a particular action/entity is part of a redundant pair listed in the "Targets" array of related user stories stored in a JSON file. As input, it receives the name and type of the first element, which is an action, and the name and type of the second element, which is an entity. It also receives a list of target pair objects, which are pairs of common actions and entities between US-pairs. For each pair, it checks whether the specified names and types match either the action or entity in the pair. If a match is found, the method returns \textit{true}, which means that the specified elements are part of a redundant pair.
	\item printRedundantItems: This method is responsible for generating a report of redundancy items based on the data stored in the class instance. It takes several parameters, including a FileWriter for writing to a file, lists of various pairs of targets, contains, and triggers, and a JSONObject for storing the report data in JSON format which is crucial for evaluation.
\end{itemize}
\subsubsection*{ReportExtractor Class: Methods related to Extracting Report}
In this subsection, the method of the ReportExtractor class is described as follows:
\begin{enumerate}
	\item extractReports: This method orchestrates the extraction and analysis of redundancy reports from a directory containing US conflict pairs and their associated reasons created by CDA tool, and generates both text and JSON reports for further investigation and processing.
	
	It receives two FileWriter objects as input, one for writing text reports and one for JSON reports.
	
	It iterates through each directory in the main directory that represents a conflict pair and uses the \textit{checkIfReportExist} method to make sure that the current US-pair are not already proceeded and the \textit{containsAnd} method to check whether it contains the conjunction \enquote{AND} to make sure that it is the valid US-pair name.
	
	For each valid conflict pair directory, iterates through the conflict reason directories within the current conflict pair directory and uses the \textit{minimalEcoreExist} method to check whether a minimal ECore file exists for a conflict reason.
	
	To identify redundancy items, it uses the method \textit{processMinimalModels} and reads a minimal model Ecore file, processes its content and iterates over the contained EPackages in order to process them further with the method \textit{iteratePackages}, which saves all redundancy items in RedundacyItems object.
	
	In addition, the methods \textit{hasEntitys}, \textit{hasActions} and \textit{hasTargets} are used to check whether the identified elements contain primary/secondary actions and primary/secondary entities and targets. If the identified elements fulfil the criteria, the redundancy pair is included in the report.
	
	It then writes the potentially redundant USs and their clauses to the text report file. It also extracts and saves relevant information in JSON format for further analysis.
	
	As output, the method returns a list of RedundantPair objects containing information about identified redundancies between USs.
	
	\item createOrOverwriteReportFile: The method is responsible for creating or overwriting report file. It first ensures the existence of a report file. If the file doesn't exist, it creates a new one; if it already exists, it overwrites the existing file. Finally, it returns a \textit{FileWriter} to allow writing to the report file.
	
	\item checkIfReportExist: This method takes two parameters, namely US-pair and the list of all previously processed pairs in the CDA report directory. It returns true if the US-pair was found in the pairList, which means that a report with the specified pairs has already been executed and therefore does not need to be executed again.
	
	\item minimalEcoreExist: This method checks the existence of a \textit{minimal-model.ecore} file using a conflict pair and a conflict reason generated by CDA.
	
	It receives a conflict pair and a conflict reason as input. Using these parameters, the method constructs the file path to the minimal-model.ecore file and checks whether the file exists under the constructed path.
	
	If the file exists, the method returns true, indicating that the minimal-model.ecore file exists for the specified conflict pair and conflict reason. If the file does not exist, it also returns false.
	
	\item containsAnd: This method ensures that the folder name is identified with \textit{\_AND\_}, as the report generated by CDA is formatted like \enquote{user\_story\textless digit \textgreater \_AND\_ user\_story\textless digit \textgreater}. It return true if the folder contains \enquote{and}, otherwise it return false.
	
	\item iteratePackages:This method identifies redundancies within the attributes and references of EClasses in a minimal model, saves them accordingly and updates the RedundancyItems object.
	
	 It takes several parameters, such as the EPackage to be iterated over, an array list in which the names of the redundant elements are stored, and a RedundancyItems object. 
	 
	 It iterates through every EClassifier in the minimal package that contains EClasses and checks whether EClass \enquote{\#} is present; if this is the case, the conflict was detected by CDA. If an attribute is found, the class of the conflicting attribute is determined and added to the corresponding section within RedundancyItems (e.g. Primary/Secondary Action/Entity). 
	 
	 Each EReference is then iterate through in the EClass. Depending on the reference name, the reference is added to the corresponding section within RedundancyItems (e.g. Triggers, Targets, Contains). The method is completed once all EClassifiers within the specified EPackage have been processed.
	
	\item processMinimalModels: This method reads a Minimal Model Ecore file, processes its content and iterates over the contained EPackages in order to process them further with the \textit{iteratePackages} method. 
	
	As parameters, it receives a File object that represents this minimal model ecore file, an array list in which the names of the redundant elements are stored, and a RedundancyItems object that is used to handle redundant elements. 
	
	First, a ResourceSet and a ResourceFactoryRegistry corresponding to the minimal model Ecore file are set up and a Resource object is created from the Ecore file; the iteratePackages method is called for each EPackage.
	
	\item hasActions: This method is useful for using the contents of a RedundancyItem to determine whether certain actions are present in a list of founded redundant entries, in order to check later whether founded clauses contain at least one other action.
	
	It checks if there's a match with name of any primary/secondary action stored in the RedundancyItems object. If match is found, it immediately returns true.
	
	\item hasEntitys: This method is used to determine whether certain secondary/primary entities  are present in the RedundancyItems object based on their name. For each item, it checks whether there is a match with the name of a primary/secondary entity stored in the RedundancyItems object. If a match is found, true is returned immediately.
	
	\item hasTargets: This method uses the content of a RedundancyItems object to determine whether targets are present in a list of founded redundant elements.
	
	It receives as input an array list with the names of the redundant elements and an object of the type RedundancyItems, which contains a collection of targets.
	
	The method checks whether there is a match with the name of any target stored in the RedundancyItems object. If a match is found between the elements, the method immediately returns true, which means that at least one target is present.
	
	\item readJsonArrayFromFile: This method provides the ability to read JSON data from a file and convert it into a JSONArray object, handling cases where the file is empty or does not exist.

	It receives the file path of the JSON file to be read as input. An attempt is made to open the specified file and check whether the file is empty or does not exist. If the file exists and is not empty, it reads the JSON data from the file and creates a JSON array object from the JSON data read from the file and returns the JSON array object with the JSON data.
	
	\item getUssTexts: This method ensures that the text of the specified US-pair is retrieved from the JSON file and properly assigned to the RedundancyItems object for further processing. It receives a US-pair and RedundancyItems as input. 
	
	It reads a JSON array from a file using the \textit{readJsonArrayFromFile} method, iterates over each JSON object in the array and compares the extracted US identifier with the US identifier extracted from the input US-pair. If a match is found, the text of the first and second USs is set in the redundancyItems object.
	
	\item applyHashSymbols: This method is used to mark certain words within a substring with hash symbols (\#) at the beginning and end to ensure that they are distinguishable and can be easily identified or processed later. 
	
	It takes a substring in which replacements are to be made and a field of matches containing the words to be surrounded with hash symbols. First, the field of matches is sorted in descending order of length and processed accordingly to avoid adding hash symbols to unwanted clauses. 
	
	For example, let's assume that we have \enquote{data} and \enquote{data format} as redundancy elements. If we continue first with \enquote{data} and then with \enquote{import data}, \enquote{import data} will be replaced by \enquote{import \#data\#}, which is not desired.
	
	\item hasMoreThanFour/SixHashSymbols: These methods receive a text from the US as input. They are used to check whether there are redundant clauses in the main part of the sentence (it can be one or two clauses). If yes, true is returned.
	
	\item applyHashSymbolPersona: This method identifies common triggers pairs between two segments of USs, marks them with hash symbols and returns the changed text segments together with the number of redundant trigger pairs. 
	
	As input, it receives a list of common trigger pairs between the USs, RedundancyItems and the segments of the USs. It iterates through the list of common trigger pairs and checks whether both elements of the trigger pair are present in both segments. 
	
	It then increments the redundancy count to keep track of the number of redundant trigger pairs. The output returned is the text of USs containing the modified text segments with hash symbols and the redundancy count.
	
	\item applyHashSymbolTargets: This method identifies common target pairs between two segments of USs, marks them with hash symbols and returns the changed text segments together with the number of redundant target pairs.
	
	As input, it receives a list of common target pairs between the USs, RedundancyItems and the segments of the USs. 
	
	It iterates through the list of common target pairs and checks whether both elements of the target pair are present in both segments. It then increments the redundancy count to keep track of the number of redundant target pairs. The output returned is the text of USs containing the modified text segments with hash symbols and the redundancy count.
	
	\item applyHashSymbolContaians: This method identifies common contain pairs between two segments of USs, marks them with hash symbols and returns the changed text segments together with the number of redundant contain pairs. 
	
	As input, it receives a list of common contain pairs between the USs, RedundancyItems and the segments of the USs. It iterates through the list of common contain pairs and checks whether both elements of the contain pair are present in both segments. 
	
	It then increments the redundancy count to keep track of the number of redundant contain pairs. The output returned is the text of USs containing the modified text segments with hash symbols and the redundancy count.
	
	\item highlightRedundancies: This method identifies redundancies between US-pair, applies hash symbols to highlight common items and updates the redundancy counts in the redundancyItems object. 
	
	It takes two parameters, redundancyItems and US-pair, which represents the pair of USs to be analysed. 
	
	It checks whether both USs contain a main clause part or whether one of them has a benefit part or whether both USs also have a benefit part. It applies hash symbols to common elements that only occur in the part of the sentence that occurs in the same segment (e.g. only main or only benefit part of the sentence). 
	
	In each condition, it checks if there are redundancy clauses in the main section, then persona is also highlighted. This method also updates the count of main/benefit/total redundancies and sets the changed text of USs. Finally, it returns the updated redundancyItems object.
	
	\item writeUsText: This method reads the text of two user stories, highlights redundants between them, writes the highlighted text to a file, and records information about the redundants. 
	
	As input it receive US-pair, array list of containing redundanted elements, a list of redundant pairs to store redundant pairs, an object type RedundancyItems containing redundancy items and a FileWriter object used for writing output.
	
	It extract the names of the two USs from US-Pair, retrieves the text of the USs from JSON file and add them to RedundancyItems, invoke the highlightRedundancies method to identify and highlight redundants between the USs, it writes the highlighted text of each US to the FileWriter, it sets the redundant pair and count of redundancy clauses.
	
	\item splitUsText: This method is used to split the text of two USs into separate sections based on the occurrence of redundancy clauses. 
	
	The input is the text of the first and second US and their corresponding identifiers, a FileWriter for writing to a file and a JSON object for processing JSON data. 
	
	It splits each US text into three parts using commas and saves the result in arrays. It iterates over parts of the first and second USs and searches for occurrences of hash symbol pairs. For each part, the number of hash symbol pairs found is counted. Finally, all parts of the records that contain hash symbols are written to a text file and a JSON file as well.
	
	\item writeUsSentencePart: This method facilitates the extraction and storage of highlighted sentence parts from USs in a file for further analysis or as a reference.
	
	As input, it receives the US-pair, RedundancyItems and a FileWriter allowing the extracted sentence parts to be written. It receives the text of the USs from the reundancyItems object and calls the \textit{splitUsText} method to split the US texts into sentence parts with highlighted elements. The extracted sentence parts are also written to the file using the FileWriter. Finally, the extracted sentence parts are saved in a JSON object for further processing and analysis.
	
	
	\item getRedundancyStatus: This method add statistics like count of main/benefit/total redundancies into JSON report. It receive as input redundancyItems and as output write the count of main/benefit/total redundancies into JSON report already defined in method highlightRedundancies.
	

	
\end{enumerate}
\subsubsection*{ReportExtractor Class: Methods related to Creating Table}
The following methods in the ReprortExtractor class are responsible for creating a suitable table at the beginning of the text report:
\begin{enumerate}
	\item writeTable: This method is used to write a table of potential redundancies between USs and the count of their total redundant elements, including the addition of the count of main and benefit redundancy elements using \textit{createTable} method.
	
	As input, it receives a file object into which the table is inserted and a list of redundancy pairs objects containing information about pairs of redundant elements in USs.
	
	It reads the existing content of the report file into a StringBuilder. It creates a table to display the potential redundancies between USs and the count of total redundancy elements. The table headers and contents are generated based on the redundant pairs. It calculates the maximum width for each column in the table to ensure proper formatting. Finally, the table content is written to the FileWriter, followed by the existing content stored in the report's StringBuilder.
	
	\item getTotalRedundanciesFromPair: This method makes it easier to retrieve the total number of redundancies between a US-pair from a list of RedundantPair objects.
	
	As input, it receives a list of RedundantPair objects containing information about pairs of redundant elements in USs, where the first and second USs are to be compared.
	
	It iterates through each RedundantPair object in the RedundantPairs list in a loop and checks for each RedundantPair object whether the pair of USs matches. If a matching pair is found, the maximum redundancy number stored in this RedundantPair object is returned. If no matching pair is found, 0 is returned, indicating that there are no redundancies between the specified US-pairs.
	
	\item createTable: This method prepares the content for the table in which potential redundancies between user stories are displayed, taking into account the total redundancy count between each pair of user stories based on the RedundantPair objects provided.
	
	As input, it receives a list of unique US-pairs for which the table is to be created and a list of RedundantPair objects containing information about pairs of redundant elements in USs.
	
	It initialises a two-dimensional array containing the contents of the table. The size of the table is determined by the count of unique pairs of USs plus one for the header row and column. It fills the header row and the first column of the table with unique pairs of US-pairs, replacing \enquote{user\_story} with \enquote{us} for the purpose of brevity. It calculates the maximum redundancy count between each pair of USs by calling the method \textit{getTotalRedundanciesFromPair}. Finally, it fills the table with the total redundancy count. 
	
	The output is a two-dimensional array representing the contents of the table, with each cell containing the maximum redundancy count between the corresponding pair of USs.
		
\end{enumerate}
\input{Section/Redundancy_Implementation}