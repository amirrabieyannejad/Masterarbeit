\subsection{Analysis by Graph Transformation Tool}\label{gts}
In a software development process, the class architecture is getting changed over the development, \emph{e.g.} due to a change of requirements, which results in a change of the class diagram. During runtime of a software, an object diagram can also be modified trough creating or deleting of new objects.

Many structures, that can be represented as graph, are able to change or mutate. This suggests the introduction of a method to modify graphs through the creation or deletion of nodes and edges. This graph modification can be performed by the so-called graph transformations. There are many approaches to model graph transformations \emph{e.g.} the double pushout approach or the single pushout approach, which are both concepts based on pushouts from category theory in the category Graphs.

In this section, some basic definitions about graph transformation and transformation rules are first established for better understanding. Afterwards, we dive into graph transformation tool Henshin \cite{arendt2010henshin}, which play a pivotal role in our methodology.

\subsection*{Graphs and Typed Graphs}
A graph consists of nodes and edges, with each edge connecting precisely two nodes and having the option to be directed or undirected. When an edge is directed, it designates a distinct start node (source) and an end node (target). For the purpose of this discussion, we will focus on directed graphs.

\begin{definition}[\textbf{graph}]
\label{def_graph}
A \emph{graph} $G = (V,E,s,t)$ contains $V$, a set of nodes, $E$, a set of edges, $s: E \to V$, a source function, where $s(e)$ is the start node of $e \in E$ and a target function $t:E \to V$, where $t(e)$ is the end node of a edge $e \in E$.
\end{definition}

\begin{definition}[\textbf{Transformation Rule}]
A \emph{transformation rule} denotes which nodes and edges of a graph have to be deleted and which nodes and edges have to be created.
In the double-pushout approach a transformation rule $p = L \xhookleftarrow{l} K \xhookrightarrow{r} R$ consists of three graphs $L,K,R$, two graph morphisms $l: K \to L$ and $r: K \to R$, where $K$ contains all elements, that remain in the graph, $L \setminus l(K)$ contains the elements that are removed and $R \setminus r(K)$ contains the elements, that are created.
\end{definition}
\begin{definition}[\textbf{Graph Transformation}]
In the context of \emph{graph transformations}, when we have two graphs $G$ and $H$, along with a transformation rule $p$, we can apply this rule to graph $G$ at match $m$. This application, denoted as $G \xRightarrow{p,m} H$, results in graph $H$. The match, represented as $m : L \hookrightarrow G$, is an injective graph morphism, and $L$ contains all the nodes and edges of $p$ that remain intact and are not deleted during the transformation.
\end{definition}
As outlined in section \ref{dmodel}, where we elucidated our utilization of conditional random fields (CRF) as a graph-based metamodeling and compositional approach for annotating USs, each US is meticulously structured and annotated in the form of a graph. Subsequently, we will apply transformation rules to these CRF-generated graphs to modelling graph transformation.

To accomplish this objective, we have harnessed the capabilities of established lexical resources such as VerbNet. This utilization of VerbNet enables us to categorize actions (which are verbs) extracted from the US into four distinct categories, namely: \enquote{create}, \enquote{delete}, \enquote{preserve}, \enquote{forbid}. These categories serve as essential components of transformation rules that articulate precise changes within the graph-based representation. 
\input{Section/GTS_Henshin}
